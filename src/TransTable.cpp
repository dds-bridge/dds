/*
   DDS, a bridge double dummy solver.

   Copyright (C) 2006-2014 by Bo Haglund /
   2014 by Bo Haglund & Soren Hein.

   See LICENSE and README.
*/

#include <stdexcept>

#include "dds.h"
#include "TransTable.h"

extern unsigned char cardRank[16];
extern char relRank[8192][15];

const char * players[DDS_HANDS] =
{
  "North", "East", "South", "West"
};



/*
   There are some constants that only need to be calculated
   once. In fact they are the same for all instances of the
   object. In order to save time and memory, they share a
   single memory.

   Each 13-bit number, aggr, represents a possible set of cards
   remaining in a suit. For example, 0x15a2 represents
   A(1) QT(5) 97(a) 3(2).

   TTlowestRank[aggr] gives the lowest relative rank that is in
   play in aggr. The ace is 14, the deuce is 2. A void counts as
   rank 15 ("not even the ace"). It would go horribly wrong
   if this rank were chosen to be 0, as might seem intuitive.
   This is not the same as lowestRank, the lowest absolute rank.

   maskBytes[aggr][suit] is a set of 4 32-bit integers,
   where suit is 0 ..3 (spades .. clubs). Each integer only
   has 8 of its 32 bits set, but these 8 bits could be either
   in the top byte (byte 0) or any of the others (bytes 1 ..3).
   The bytes are abbreviated as B0 .. B3 below.

                     int 0 int 1 int 2 int 3
   suit 0, spades B0 R0 B0 R1 B0 R2 B0 R3
   suit 1, hearts B1 R0 B1 R1 B1 R2 B1 R3
   suit 2, diamonds B2 R0 B2 R1 B2 R2 B2
   suit 3, clubs B3 R0 B3 R1 B3 R2 B3

   R0 .. R3 are explained now. The purpose of maskBytes is
   to generate 32-bit masks for later use with actual suits.
   As a card can be with either of 4 players, 2 bits are needed
   to encode the position of a card. Therefore the masks also
   need 2 bits per card, even though the 2 bits are identical.

   In the table, R0 means the top byte (8 bits = 4 cards) of
   a holding.

   R0 AKQJ
   R1 T987
   R2 6543
   R3 2

   For example, if the ace is held by North, the king by South, the
   queen and jack by West, then the top byte for that SUIT would be

   00(North) 10(South) 11(West) 11(West)

   The MASK for that holding would be 11 11 11 11, as all four
   cards are in play.

   If the jack were missing, because it had already been played,
   then the suit would be 00 10 11 00 (a missing card is also
   encoded as 00), and the mask would be 11 11 11 00.

   Later on, when we have a specific set of spades .. clubs,
   we want to check whether those cards are already in the
   transposition table. As far as the necessary masks is
   concerned, this is generated by an OR (|) of the four
   32-bit integers in a column of the table above.

   So the first column yields four bytes which are already
   shifted in place, all corresponding to R0. The mask
   corresponds to the AKQJ of the four suits in order.

   It's not really AKQJ, but the four highest cards still in
   play in that suit. So missing cards are always at the end
   of the list.
*/

bool _constantsSet = false;
unsigned maskBytes[8192][DDS_SUITS][TT_BYTES];
int TTlowestRank[8192];


TransTable::TransTable()
{
  if (! _constantsSet)
  {
    _constantsSet = true;
    TransTable::SetConstants();
  }

  poolp = nullptr;
  pagesDefault = NUM_PAGES_DEFAULT;
  pagesMaximum = NUM_PAGES_MAXIMUM;
  pagesCurrent = 0;

  memState = FROM_POOL;
  harvestTrick = FIRST_HARVEST_TRICK;
  harvestHand = 0;

  harvested.nextBlockNo = 0;

  timestamp = 0;

  pageStats.numResets = 0;
  pageStats.numCallocs = 0;
  pageStats.numFrees = 0;
  pageStats.numHarvests = 0;
  pageStats.lastCurrent = 0;

  TTInUse = 0;

  strcpy(fname, "");
  fp = stdout;
}


TransTable::~TransTable()
{
  TransTable::ReturnAllMemory();

  if (fp != stdout && fp != nullptr)
    fclose(fp);
}


void TransTable::SetConstants()
{
  unsigned winMask[8192];

  unsigned int topBitRank = 1;
  winMask[0] = 0;
  TTlowestRank[0] = 15; // Void

  for (unsigned ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank + topBitRank)) /* Next top bit */
      topBitRank <<= 1;

    // winMask is a growing list of 11's. In the end it will
    // have 26 bits, so 13 groups of two bits. It always
    // consists of all 11's, then all 00's.

    winMask[ind] = (winMask[ind ^ topBitRank] >> 2) | (3 << 24);

    maskBytes[ind][0][0] = (winMask[ind] << 6) & 0xff000000;
    maskBytes[ind][0][1] = (winMask[ind] << 14) & 0xff000000;
    maskBytes[ind][0][2] = (winMask[ind] << 22) & 0xff000000;
    maskBytes[ind][0][3] = (winMask[ind] << 30) & 0xff000000;

    maskBytes[ind][1][0] = (winMask[ind] >> 2) & 0x00ff0000;
    maskBytes[ind][1][1] = (winMask[ind] << 6) & 0x00ff0000;
    maskBytes[ind][1][2] = (winMask[ind] << 14) & 0x00ff0000;
    maskBytes[ind][1][3] = (winMask[ind] << 22) & 0x00ff0000;

    maskBytes[ind][2][0] = (winMask[ind] >> 10) & 0x0000ff00;
    maskBytes[ind][2][1] = (winMask[ind] >> 2) & 0x0000ff00;
    maskBytes[ind][2][2] = (winMask[ind] << 6) & 0x0000ff00;
    maskBytes[ind][2][3] = (winMask[ind] << 14) & 0x0000ff00;

    maskBytes[ind][3][0] = (winMask[ind] >> 18) & 0x000000ff;
    maskBytes[ind][3][1] = (winMask[ind] >> 10) & 0x000000ff;
    maskBytes[ind][3][2] = (winMask[ind] >> 2) & 0x000000ff;
    maskBytes[ind][3][3] = (winMask[ind] << 6) & 0x000000ff;

    TTlowestRank[ind] = TTlowestRank[ind ^ topBitRank] - 1;
  }
}


void TransTable::Init(int handLookup[][15])
{
  // This is very similar to SetConstants, except that it
  // happens with actual cards. It also makes sense to
  // keep a record of aggrRanks for each suit. These are
  // only used later for xorSet.

  unsigned int topBitRank = 1;
  unsigned int topBitNo = 2;
  aggrType * ap;

  for (int s = 0; s < DDS_SUITS; s++)
  {
    aggr[0].aggrRanks[s] = 0;
    aggr[0].aggrBytes[s][0] = 0;
    aggr[0].aggrBytes[s][1] = 0;
    aggr[0].aggrBytes[s][2] = 0;
    aggr[0].aggrBytes[s][3] = 0;
  }

  for (unsigned ind = 1; ind < 8192; ind++)
  {
    if (ind >= (topBitRank << 1))
    {
      /* Next top bit */
      topBitRank <<= 1;
      topBitNo++;
    }

    aggr[ind] = aggr[ind ^ topBitRank];
    ap = &aggr[ind];

    for (int s = 0; s < DDS_SUITS; s++)
    {
      ap->aggrRanks[s] = ap->aggrRanks[s] >> 2 |
                          static_cast<unsigned>(handLookup[s][topBitNo] << 24);
    }

    ap->aggrBytes[0][0] = (ap->aggrRanks[0] << 6) & 0xff000000;
    ap->aggrBytes[0][1] = (ap->aggrRanks[0] << 14) & 0xff000000;
    ap->aggrBytes[0][2] = (ap->aggrRanks[0] << 22) & 0xff000000;
    ap->aggrBytes[0][3] = (ap->aggrRanks[0] << 30) & 0xff000000;

    ap->aggrBytes[1][0] = (ap->aggrRanks[1] >> 2) & 0x00ff0000;
    ap->aggrBytes[1][1] = (ap->aggrRanks[1] << 6) & 0x00ff0000;
    ap->aggrBytes[1][2] = (ap->aggrRanks[1] << 14) & 0x00ff0000;
    ap->aggrBytes[1][3] = (ap->aggrRanks[1] << 22) & 0x00ff0000;

    ap->aggrBytes[2][0] = (ap->aggrRanks[2] >> 10) & 0x0000ff00;
    ap->aggrBytes[2][1] = (ap->aggrRanks[2] >> 2) & 0x0000ff00;
    ap->aggrBytes[2][2] = (ap->aggrRanks[2] << 6) & 0x0000ff00;
    ap->aggrBytes[2][3] = (ap->aggrRanks[2] << 14) & 0x0000ff00;

    ap->aggrBytes[3][0] = (ap->aggrRanks[3] >> 18) & 0x000000ff;
    ap->aggrBytes[3][1] = (ap->aggrRanks[3] >> 10) & 0x000000ff;
    ap->aggrBytes[3][2] = (ap->aggrRanks[3] >> 2) & 0x000000ff;
    ap->aggrBytes[3][3] = (ap->aggrRanks[3] << 6) & 0x000000ff;
  }
}


void TransTable::SetMemoryDefault(int megabytes)
{
  double blockMem = BLOCKS_PER_PAGE * sizeof(winBlockType) /
                    static_cast<double>(1024.);

  pagesDefault = static_cast<int>((1024 * megabytes) / blockMem);
}


void TransTable::SetMemoryMaximum(int megabytes)
{
  double blockMem = BLOCKS_PER_PAGE * sizeof(winBlockType) /
                    static_cast<double>(1024.);

  pagesMaximum = static_cast<int>((1024 * megabytes) / blockMem);
}


void TransTable::MakeTT()
{
  if (! TTInUse)
  {
    TTInUse = 1;

    for (int t = 0; t < TT_TRICKS; t++)
    {
      for (int h = 0; h < DDS_HANDS; h++)
      {
        TTroot[t][h] = static_cast<distHashType *>
                       (malloc(256 * sizeof(distHashType)));

        if (TTroot[t][h] == nullptr)
          exit(1);
      }
    }
  }

  TransTable::InitTT();
}


void TransTable::InitTT()
{
  for (int c = 0; c < TT_TRICKS; c++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      for (int i = 0; i < 256; i++)
      {
        TTroot[c][h][i].nextNo = 0;
        TTroot[c][h][i].nextWriteNo = 0;

      }
      lastBlockSeen[c][h] = nullptr;
    }
  }
}


void TransTable::ReleaseTT()
{
  if (! TTInUse)
    return;
  TTInUse = 0;

  for (int t = 0; t < TT_TRICKS; t++)
  {
    for (int h = 0; h < DDS_HANDS; h++)
    {
      if (TTroot[t][h] == nullptr)
        continue;

      free(TTroot[t][h]);
    }
  }
}


void TransTable::ResetMemory()
{
  if (poolp == nullptr)
    return;

  pageStats.numResets++;
  pageStats.numCallocs += pagesCurrent - pageStats.lastCurrent;
  pageStats.lastCurrent = pagesCurrent;

  while (pagesCurrent > pagesDefault)
  {
    free(poolp->list);
    poolp = poolp->prev;

    free(poolp->next);
    poolp->next = nullptr;

    pagesCurrent--;
  }

  pageStats.numFrees += pageStats.lastCurrent - pagesCurrent;
  pageStats.lastCurrent = pagesCurrent;

  while (poolp->prev)
    poolp = poolp->prev;

  poolp->nextBlockNo = 0;
  nextBlockp = poolp->list;

  TransTable::InitTT();

  timestamp = 0;

  memState = FROM_POOL;

  return;
}


void TransTable::ReturnAllMemory()
{
  poolType * tmp;

  if (poolp)
  {
    while (poolp->next)
      poolp = poolp->next;

    while (poolp)
    {
      free(poolp->list);
      tmp = poolp;
      poolp = poolp->prev;
      free(tmp);
    }
  }

  pagesCurrent = 0;

  pageStats.numResets = 0;
  pageStats.numCallocs = 0;
  pageStats.numFrees = 0;
  pageStats.numHarvests = 0;
  pageStats.lastCurrent = 0;

  TransTable::ReleaseTT();

  return;
}


int TransTable::BlocksInUse()
{
  poolType * pp = poolp;
  int count = 0;

  do
  {
    count += pp->nextBlockNo;
    pp = pp->prev;
  }
  while (pp);

  return count;
}


double TransTable::MemoryInUse()
{
  int blockMem = BLOCKS_PER_PAGE * pagesCurrent *
                 static_cast<int>(sizeof(winBlockType));
  int aggrMem = 8192 * static_cast<int>(sizeof(aggrType));
  int rootMem = TT_TRICKS * DDS_HANDS * 256 *
                 static_cast<int>(sizeof(distHashType));

  return (blockMem + aggrMem + rootMem) / static_cast<double>(1024.);
}


TransTable::winBlockType * TransTable::GetNextCardBlock()
{
  /*
     Spaghetti code. The basic idea is that there is a pool of
     pages. When a page runs out, we get a next pool. But we're
     only allowed a certain maximum number, and calloc might also
     fail before then. We have a default number of pages that
     we don't give back voluntarily once we have acquired them,
     but we give back anything more than that at the end of each
     hand. If this overall mechanism fails, then we try to harvest
     old entries scattered throughout the TT memory. If we get
     enough for a "page", then we use that single page, and if
     that runs out later, we try to harvest some more, starting
     where we left off harvesting last time. If the harvesting also
     fails, then we reset whatever TT memory we do have, and we
     continue with that.
  */

  if (poolp == nullptr)
  {
    // Have to be able to get at least one pool.
    poolp = static_cast<poolType *>(calloc(1, sizeof(poolType)));
    if (poolp == nullptr)
      exit(1);

    poolp->list = static_cast<winBlockType *>
                  (malloc(BLOCKS_PER_PAGE * sizeof(winBlockType)));

    if (! poolp->list)
      exit(1);

    poolp->next = nullptr;
    poolp->prev = nullptr;
    poolp->nextBlockNo = 1;

    nextBlockp = poolp->list;

    pagesCurrent++;

    return nextBlockp++;
  }
  else if (memState == FROM_HARVEST)
  {
    // Not allowed to get more memory, so reuse old one.
    int n = harvested.nextBlockNo;
    if (n == BLOCKS_PER_PAGE)
    {
      if (! TransTable::Harvest())
      {
        TransTable::ResetMemory();
        poolp->nextBlockNo++;
        return nextBlockp++;
      }
      n = 0;
    }

    harvested.nextBlockNo++;
    return harvested.list[n];
  }
  else if (poolp->nextBlockNo == BLOCKS_PER_PAGE)
  {
    if (poolp->next)
    {
      // Reuse a dormant block that has not been freed.
      poolp = poolp->next;
      poolp->nextBlockNo = 1;
      nextBlockp = poolp->list;

      return nextBlockp++;
    }
    else if (pagesCurrent == pagesMaximum)
    {
      // Have to try to reclaim memory.
      if (! TransTable::Harvest())
      {
        TransTable::ResetMemory();
        poolp->nextBlockNo++;
        return nextBlockp++;
      }

      memState = FROM_HARVEST;
      harvested.nextBlockNo++;
      return harvested.list[0];
    }
    else
    {
      // Make a new pool.
      poolType * newpoolp = static_cast<poolType *>
                            (calloc(1, sizeof(poolType)));

      if (newpoolp == nullptr)
      {
        // Unexpected, but try harvesting before we give up
        // and start over.
        if (! TransTable::Harvest())
        {
          TransTable::ResetMemory();
          poolp->nextBlockNo++;
          return nextBlockp++;
        }

        memState = FROM_HARVEST;
        harvested.nextBlockNo++;
        return harvested.list[0];
      }

      newpoolp->list = static_cast<winBlockType *>
                       (malloc(BLOCKS_PER_PAGE * sizeof(winBlockType)));

      if (! newpoolp->list)
      {
        if (! TransTable::Harvest())
        {
          TransTable::ResetMemory();
          poolp->nextBlockNo++;
          return nextBlockp++;
        }

        memState = FROM_HARVEST;
        harvested.nextBlockNo++;
        return harvested.list[0];
      }

      newpoolp->nextBlockNo = 1;
      newpoolp->next = nullptr;
      newpoolp->prev = poolp;

      poolp->next = newpoolp;
      poolp = newpoolp;

      nextBlockp = newpoolp->list;

      pagesCurrent++;

      return nextBlockp++;
    }
  }

  poolp->nextBlockNo++;
  return nextBlockp++;
}


bool TransTable::Harvest()
{
  distHashType * rootptr = TTroot[harvestTrick][harvestHand];
  distHashType * ptr;
  winBlockType * bp;

  int trick = harvestTrick;
  int hand = harvestHand;
  int hash, suit, hno = 0;

  while (1)
  {
    for (hash = 0; hash < 256; hash++)
    {
      ptr = &rootptr[hash];
      for (suit = ptr->nextNo - 1; suit >= 0; suit--)
      {
        bp = ptr->list[suit].posBlock;
        if (timestamp - bp->timestampRead > HARVEST_AGE)
        {
          bp->nextMatchNo = 0;
          bp->nextWriteNo = 0;
          bp->timestampRead = timestamp;
          harvested.list[hno] = bp;

          // Swap the last element down.
          if (suit != ptr->nextNo - 1)
            ptr->list[suit] = ptr->list[ ptr->nextNo - 1 ];

          ptr->nextNo--;
          ptr->nextWriteNo = ptr->nextNo;

          if (++hno == BLOCKS_PER_PAGE)
          {
            if (++harvestHand >= DDS_HANDS)
            {
              // Skip rest of this [trick][hand] for simplicity.
              harvestHand = 0;
              if (--harvestTrick < 0)
                harvestTrick = FIRST_HARVEST_TRICK;
            }

            harvested.nextBlockNo = 0;
            pageStats.numHarvests++;
            return true;
          }
        }
      }
    }

    if (++harvestHand >= DDS_HANDS)
    {
      harvestHand = 0;
      if (--harvestTrick < 0)
        harvestTrick = FIRST_HARVEST_TRICK;
    }

    if (harvestTrick == trick && harvestHand == hand)
      return false;

    rootptr = TTroot[harvestTrick][harvestHand];
  }
}


int TransTable::hash8(int * handDist)
{
  /*
     handDist is an array of hand distributions, North .. West.
     Each entry is a 12-bit number with 3 groups of 4 bits.
     Each group is the binary representation of the number of
     cards held in that suit. The suits are in order spades,
     hearts, diamonds. Clubs can be neglected, as the total
     number of cards in a hand is given by the trick number.

     For example, if handDist[1] equals 0x0433, then East holds
     4 spades, 3 hearts, 3 diamonds and the rest in clubs.
     If this is after the second trick, there are 11 cards, so
     East must hold 1 club.

     The hash function turns all 4 hand distributions into a
     single 8-bit number. The numbers should be spread as
     evenly as possible across the 256 possibilities. I've not
     done extensive research into finding the best hash function,
     but this one seems OK. It uses a small prime, 5, and its
     powers. The shift at the end is in order to get some use
     out of the bits above the first 8 ones.
  */

  int h =
    (handDist[0] ^
     ((handDist[1] * 5) ) ^
     ((handDist[2] * 25) ) ^
     ((handDist[3] * 125) ) );

  return (h ^ (h >> 5)) & 0xff;
}


void TransTable::Top4Ranks(
  unsigned short aggrTarget[],
  unsigned rr[DDS_SUITS])
{
  // This is just a service function to reuse some tables.
  // It is not part of the transposition table as such.

  rr[0] = (aggr[ aggrTarget[0] ].aggrBytes[0][0]) >> 24;
  rr[1] = (aggr[ aggrTarget[1] ].aggrBytes[1][0]) >> 16;
  rr[2] = (aggr[ aggrTarget[2] ].aggrBytes[2][0]) >> 8;
  rr[3] = (aggr[ aggrTarget[3] ].aggrBytes[3][0]);
}


nodeCardsType * TransTable::Lookup(
  int tricks,
  int hand,
  unsigned short aggrTarget[],
  int handDist[],
  int limit,
  bool * lowerFlag)
{
  // First look up distribution.
  long long suitLengths =
    (static_cast<long long>(handDist[0]) << 36) |
    (static_cast<long long>(handDist[1]) << 24) |
    (static_cast<long long>(handDist[2]) << 12) |
    (static_cast<long long>(handDist[3]) );

  int hashkey = hash8(handDist);

  bool empty;
  lastBlockSeen[tricks][hand] =
    LookupSuit(&TTroot[tricks][hand][hashkey],
               suitLengths, &empty);
  if (empty)
    return nullptr;

  // If that worked, look up cards.
  unsigned * ab0 = aggr[ aggrTarget[0] ].aggrBytes[0];
  unsigned * ab1 = aggr[ aggrTarget[1] ].aggrBytes[1];
  unsigned * ab2 = aggr[ aggrTarget[2] ].aggrBytes[2];
  unsigned * ab3 = aggr[ aggrTarget[3] ].aggrBytes[3];

  winMatchType TTentry;
  TTentry.topSet1 = ab0[0] | ab1[0] | ab2[0] | ab3[0];
  TTentry.topSet2 = ab0[1] | ab1[1] | ab2[1] | ab3[1];
  TTentry.topSet3 = ab0[2] | ab1[2] | ab2[2] | ab3[2];
  TTentry.topSet4 = ab0[3] | ab1[3] | ab2[3] | ab3[3];

  return TransTable::LookupCards(&TTentry,
    lastBlockSeen[tricks][hand], limit, lowerFlag);
}


TransTable::winBlockType * TransTable::LookupSuit(
  distHashType * dp,
  long long key,
  bool * empty)
{
  /*
     Always returns a valid winBlockType.
     If empty == true, there was no match, so there is
     no point in looking for a card match.
     If empty == false, there were entries already.
  */

  int n = dp->nextNo;
  for (int i = 0; i < n; i++)
  {
    if (dp->list[i].key == key)
    {
      *empty = false;
      return dp->list[i].posBlock;
    }
  }

  *empty = true;
  int m;

  if (n == DISTS_PER_ENTRY)
  {
    // No room for new exact suits at this hash position.
    // Have to reuse an existing posBlock.
    if (dp->nextWriteNo == DISTS_PER_ENTRY)
    {
      m = 0;
      dp->nextWriteNo = 1;
    }
    else
      m = dp->nextWriteNo++;
  }
  else
  {
    // Didn't find an exact match, but there is still room.
    // The following looks a bit odd because it is possible that
    // GetNextCardBlock wipes out the whole memory, so we
    // have to use the up-to-date location, not m from above.

    winBlockType * bp = GetNextCardBlock();
    m = dp->nextWriteNo++;
    dp->list[m].posBlock = bp;
    dp->list[m].posBlock->timestampRead = timestamp;
    dp->nextNo++;
  }

  // As long as the secondary Lookup loop in ABsearch exists,
  // it will cause spurious extra blocks to be created here
  // which are not useful, because nothing is ever Add'ed.
  // This is not a memory leak, as the memory is properly freed,
  // but it is also a small waste of about 0.5%. I don't mind.

  dp->list[m].key = key;
  dp->list[m].posBlock->nextMatchNo = 0;
  dp->list[m].posBlock->nextWriteNo = 0;

  return dp->list[m].posBlock;
}


nodeCardsType * TransTable::LookupCards(
  winMatchType * searchp,
  winBlockType * bp,
  int limit,
  bool * lowerFlag)
{
  winMatchType * wp;

  int n = bp->nextWriteNo - 1;
  wp = &bp->list[n];

  // It may be a bit silly to duplicate the code like this.
  // It could be combined to one loop with a slight overhead.

  for (int i = n; i >= 0; i--, wp--)
  {
    if ((wp->topSet1 ^ searchp->topSet1) & wp->topMask1)
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ searchp->topSet2) & wp->topMask2)
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ searchp->topSet3) & wp->topMask3)
          continue;
      }
    }

    // Check bounds.
    nodeCardsType * nodep = &wp->first;
    if (nodep->lbound > limit)
    {
      bp->timestampRead = ++timestamp;
      * lowerFlag = true;
      return nodep;
    }
    else if (nodep->ubound <= limit)
    {
      bp->timestampRead = ++timestamp;
      * lowerFlag = false;
      return nodep;
    }
  }

  int n2 = bp->nextMatchNo - 1;
  wp = &bp->list[n2];

  for (int i = n2; i > n; i--, wp--)
  {
    if ((wp->topSet1 ^ searchp->topSet1) & wp->topMask1)
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ searchp->topSet2) & wp->topMask2)
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ searchp->topSet3) & wp->topMask3)
          continue;
      }
    }

    nodeCardsType * nodep = &wp->first;
    if (nodep->lbound > limit)
    {
      * lowerFlag = true;
      bp->timestampRead = ++timestamp;
      return nodep;
    }
    else if (nodep->ubound <= limit)
    {
      * lowerFlag = false;
      bp->timestampRead = ++timestamp;
      return nodep;
    }
  }

  return nullptr;
}


void TransTable::CreateOrUpdate(
  winBlockType * bp,
  winMatchType * searchp,
  bool flag)
{
  // Either updates an existing SOP or creates a new one.
  // A new one is created at the end of the bp list if this
  // is not already full, or the oldest one in the list is
  // overwritten.

  winMatchType * wp = bp->list;
  int n = bp->nextMatchNo;

  for (int i = 0; i < n; i++, wp++)
  {
    if (wp->xorSet != searchp->xorSet ) continue;
    if (wp->maskIndex != searchp->maskIndex) continue;
    if (wp->topSet1 != searchp->topSet1 ) continue;
    if (wp->topSet2 != searchp->topSet2 ) continue;
    if (wp->topSet3 != searchp->topSet3 ) continue;

    nodeCardsType * nodep = &wp->first;
    if (searchp->first.lbound > nodep->lbound)
      nodep->lbound = searchp->first.lbound;
    if (searchp->first.ubound < nodep->ubound)
      nodep->ubound = searchp->first.ubound;

    nodep->bestMoveSuit = searchp->first.bestMoveSuit;
    nodep->bestMoveRank = searchp->first.bestMoveRank;
    return;
  }

  if (n == BLOCKS_PER_ENTRY)
  {
    if (bp->nextWriteNo >= BLOCKS_PER_ENTRY)
      bp->nextWriteNo = 0;
  }
  else
    bp->nextMatchNo++;


  wp = &bp->list[ bp->nextWriteNo++ ];
  *wp = *searchp;

  if (!flag)
  {
    wp->first.bestMoveSuit = 0;
    wp->first.bestMoveRank = 0;
  }
}


void TransTable::Add(
  int tricks,
  int hand,
  unsigned short * aggrTarget,
  unsigned short * ourWinRanks,
  nodeCardsType * first,
  bool flag)
{
  if (lastBlockSeen[tricks][hand] == nullptr)
  {
    // We have recently reset the entire memory, and we were
    // in the middle of a recursion. So we'll just have to
    // drop this entry that we were supposed to be adding.
    return;
  }

  unsigned * ab[DDS_SUITS];
  unsigned * mb[DDS_SUITS];
  char low[DDS_SUITS];
  unsigned short int ag;
  int w;
  winMatchType TTentry;

  // Inefficient, as it also copies leastWin.
  // In fact I'm not quite happy with the treatment of
  // leastWin in general.

  TTentry.first = *first;

  TTentry.xorSet = 0;

  for (int ss = 0; ss < DDS_SUITS; ss++)
  {
    w = static_cast<int>(ourWinRanks[ss]);
    if (w == 0)
    {
      ab[ss] = aggr[0].aggrBytes[ss];
      mb[ss] = maskBytes[0][ss];
      low[ss] = 15;
      TTentry.first.leastWin[ss] = 0;
    }
    else
    {
      w = w & (-w); /* Only lowest win */
      ag = static_cast<unsigned short>(aggrTarget[ss] & (-w));

      ab[ss] = aggr[ag].aggrBytes[ss];
      mb[ss] = maskBytes[ag][ss];
      low[ss] = static_cast<char>(TTlowestRank[ag]);

      TTentry.first.leastWin[ss] = 15 - low[ss];
      TTentry.xorSet ^= aggr[ag].aggrRanks[ss];
    }
  }

  // It's a bit annoying that we may be regenerating these.
  // But winRanks can cause them to change after lookup().

  TTentry.topSet1 = ab[0][0] | ab[1][0] | ab[2][0] | ab[3][0];
  TTentry.topSet2 = ab[0][1] | ab[1][1] | ab[2][1] | ab[3][1];
  TTentry.topSet3 = ab[0][2] | ab[1][2] | ab[2][2] | ab[3][2];
  TTentry.topSet4 = ab[0][3] | ab[1][3] | ab[2][3] | ab[3][3];

  TTentry.topMask1 = mb[0][0] | mb[1][0] | mb[2][0] | mb[3][0];
  TTentry.topMask2 = mb[0][1] | mb[1][1] | mb[2][1] | mb[3][1];
  TTentry.topMask3 = mb[0][2] | mb[1][2] | mb[2][2] | mb[3][2];
  TTentry.topMask4 = mb[0][3] | mb[1][3] | mb[2][3] | mb[3][3];

  TTentry.maskIndex =
    (low[0] << 12) | (low[1] << 8) | (low[2] << 4) | low[3];

  if (TTentry.topMask2 == 0)
    TTentry.lastMaskNo = 1;
  else if (TTentry.topMask3 == 0)
    TTentry.lastMaskNo = 2;
  else if (TTentry.topMask4 == 0)
    TTentry.lastMaskNo = 3;
  else
    TTentry.lastMaskNo = 4;

  TransTable::CreateOrUpdate(lastBlockSeen[tricks][hand],
                             &TTentry, flag);
}



void TransTable::PrintMatch(
  winMatchType * wp,
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN];
  int used[DDS_HANDS][DDS_SUITS];

  for (int h = 0; h < DDS_HANDS; h++)
  {
    for (int s = 0; s < DDS_SUITS; s++)
    {
      used[h][s] = 0;
      for (int c = 0; c < TT_LINE_LEN; c++)
        hands[h][s][c] = 0;
    }
  }

  TransTable::SetToPartialHands(
    wp->topSet1, wp->topMask1, 14, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet2, wp->topMask2, 10, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet3, wp->topMask3, 6, 4, hands, used);
  TransTable::SetToPartialHands(
    wp->topSet4, wp->topMask4, 2, 1, hands, used);

  TransTable::DumpHands(hands, lengths);

  TransTable::PrintNodeValues(&wp->first);
}


void TransTable::PrintNodeValues(
  nodeCardsType * np)
{
  if (!np)
  {
    fprintf(fp, "np == nullptr\n");
    return;
  }

  fprintf(fp, "Lowest used\t%c%c, %c%c, %c%c, %c%c\n",
          cardSuit[0], cardRank[ 15 - static_cast<int>(np->leastWin[0]) ],
          cardSuit[1], cardRank[ 15 - static_cast<int>(np->leastWin[1]) ],
          cardSuit[2], cardRank[ 15 - static_cast<int>(np->leastWin[2]) ],
          cardSuit[3], cardRank[ 15 - static_cast<int>(np->leastWin[3]) ]);

  fprintf(fp, "Bounds\t\t%d to %2d tricks\n",
          static_cast<int>(np->lbound),
          static_cast<int>(np->ubound));

  fprintf(fp, "Best move\t%c%c\n",
          cardSuit[ static_cast<int>(np->bestMoveSuit) ],
          cardRank[ static_cast<int>(np->bestMoveRank) ]);

  fprintf(fp, "\n");
}


void TransTable::MakeHolding(
  char * high,
  unsigned len,
  char * res)
{
  unsigned l = strlen(high);
  strcpy(res, high);

  if (len == 0 && (l == 0 || (l == 1 && high[0] == '\0')))
  {
    res[0] = '-';
    res[1] = '\0';
    return;
  }

  for (unsigned i = l; i < len; i++)
  {
    res[i] = 'x';
  }
  res[len] = '\0';
}


void TransTable::DumpHands(
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN],
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  char res_a[TT_LINE_LEN], res_b[TT_LINE_LEN];

  for (int i = 0; i < DDS_SUITS; i++)
  {
    TransTable::MakeHolding(hands[0][i],
                            static_cast<unsigned>(lengths[0][i]), res_a);
    fprintf(fp, "%16s%s\n", "", res_a);
  }

  for (int i = 0; i < DDS_SUITS; i++)
  {
    TransTable::MakeHolding(hands[3][i],
                            static_cast<unsigned>(lengths[3][i]), res_a);
    TransTable::MakeHolding(hands[1][i],
                            static_cast<unsigned>(lengths[1][i]), res_b);
    fprintf(fp, "%-16s%16s%-16s\n", res_a, "", res_b);
  }

  for (int i = 0; i < DDS_SUITS; i++)
  {
    char res[16];
    TransTable::MakeHolding(hands[2][i],
                            static_cast<unsigned>(lengths[2][i]), res);
    fprintf(fp, "%16s%s\n", "", res);
  }
  fprintf(fp, "\n");
}


void TransTable::SetToPartialHands(
  unsigned set,
  unsigned mask,
  int maxRank,
  int numRanks,
  char hands[DDS_HANDS][DDS_SUITS][TT_LINE_LEN],
  int used[DDS_HANDS][DDS_SUITS])
{
  for (int s = 0; s < DDS_SUITS; s++)
  {
    for (int rank = maxRank; rank > maxRank - numRanks; rank--)
    {
      int shift = 8 * (3 - s) + 2 * (rank - maxRank + 3);
      unsigned maskCard = mask >> shift;

      if (maskCard & 3)
      {
        unsigned player = (set >> shift) & 3;
        hands[player][s][ used[player][s]++ ] =
          static_cast<char>(cardRank[rank]);
      }
    }
  }
}


void TransTable::SetFile(char * ourFname)
{
  if (strlen(ourFname) > TT_LINE_LEN)
    return;

  if (fp != stdout) // Already set
    return;

  strncpy(fname, ourFname, strlen(ourFname));

  fp = fopen(fname, "w");
  if (! fp)
    fp = stdout;
}


void TransTable::KeyToDist(
  long long key,
  int handDist[])
{
  handDist[0] = static_cast<int>((key >> 36) & 0x00000fff);
  handDist[1] = static_cast<int>((key >> 24) & 0x00000fff);
  handDist[2] = static_cast<int>((key >> 12) & 0x00000fff);
  handDist[3] = static_cast<int>((key ) & 0x00000fff);
}


void TransTable::DistToLengths(
  int trick,
  int handDist[],
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  for (int h = 0; h < DDS_HANDS; h++)
  {
    lengths[h][0] = static_cast<unsigned char>((handDist[h] >> 8) & 0xf);
    lengths[h][1] = static_cast<unsigned char>((handDist[h] >> 4) & 0xf);
    lengths[h][2] = static_cast<unsigned char>((handDist[h] ) & 0xf);
    lengths[h][3] = static_cast<unsigned char>
                    (trick + 1
                     - lengths[h][0]
                     - lengths[h][1]
                     - lengths[h][2]);
  }
}


void TransTable::LenToStr(
  unsigned char len[DDS_HANDS][DDS_SUITS],
  char * line)
{
  sprintf(line,
          "%d=%d=%d=%d \t%d=%d=%d=%d \t%d=%d=%d=%d \t%d=%d=%d=%d",
          len[0][0], len[0][1], len[0][2], len[0][3],
          len[1][0], len[1][1], len[1][2], len[1][3],
          len[2][0], len[2][1], len[2][2], len[2][3],
          len[3][0], len[3][1], len[3][2], len[3][3]);
}


void TransTable::PrintSuits(
  int trick,
  int hand)
{
  distHashType * dp;
  int handDist[DDS_HANDS];
  unsigned char len[DDS_HANDS][DDS_SUITS];
  char line[40];

  fprintf(fp, "%4s %2s %-8s\t%-8s\t%-8s\t%-8s\n",
          "Key",
          "No",
          players[0],
          players[1],
          players[2],
          players[3]);

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    if (dp->nextNo == 0)
      continue;

    for (int i = 0; i < dp->nextNo; i++)
    {
      if (i == 0)
        fprintf(fp, "0x%02x %2d ", hashkey, dp->nextNo);
      else
        fprintf(fp, "%4s %2s " , "", "");

      TransTable::KeyToDist(dp->list[i].key, handDist);
      TransTable::DistToLengths(trick, handDist, len);

      TransTable::LenToStr(len, line);
      fprintf(fp, "%s\n", line);
    }
  }
  fprintf(fp, "\n");
}


void TransTable::PrintAllSuits()
{
  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "====================\n\n");

      TransTable::PrintSuits(trick, hand);
    }
  }
}


void TransTable::MakeHistStats(
  int hist[],
  int * count,
  int * prod_sum,
  int * prod_sumsq,
  int * max_len,
  int last_index)
{
  *count = 0;
  *prod_sum = 0;
  *prod_sumsq = 0;
  *max_len = 0;

  for (int i = 1; i <= last_index; i++)
  {
    if (hist[i])
    {
      *prod_sum += i * hist[i];
      *prod_sumsq += i * i * hist[i];
      *count += hist[i];

      if (i > *max_len)
        *max_len = i;
    }
  }
}


int TransTable::CalcPercentile(
  int hist[],
  double threshold,
  int last_index)
{
  int cum = 0;

  for (int i = 1; i <= last_index; i++)
  {
    cum += hist[i];
    if (cum >= threshold)
      return i;
  }
  return -1;
}


void TransTable::PrintHist(
  int hist[],
  int num_wraps,
  int last_index)
{
  int count, prod_sum, prod_sumsq, max_len;

  TransTable::MakeHistStats(hist,
                            &count, &prod_sum, &prod_sumsq, &max_len, last_index);

  for (int i = 1; i <= last_index; i++)
    if (hist[i])
      fprintf(fp, "%7d\t%5d\n", i, hist[i]);

  fprintf(fp, "\n");
  fprintf(fp, "Entries\t%5d\n", count);
  if (count)
  {
    fprintf(fp, "Full\t%5d\n", num_wraps);

    double mean = prod_sum / static_cast<double>(count);
    fprintf(fp, "Average\t%5.2f\n", mean);

    double var = prod_sumsq /
                 static_cast<double>(count - mean * mean);
    if (var >= 0.)
      fprintf(fp, "Std.dev\t%5.2f\n", sqrt(var));

    fprintf(fp, "Maximum\t%5d\n", max_len);
  }
  fprintf(fp, "\n");
}


void TransTable::UpdateSuitHist(
  int trick,
  int hand,
  int hist[],
  int * num_wraps)
{
  distHashType * dp;

  * num_wraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    hist[i] = 0;

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    hist [ dp->nextNo ]++;
    suitHist[ dp->nextNo ]++;

    if (dp->nextNo != dp->nextWriteNo)
    {
      (*num_wraps)++; // Not entirely correct
      suitWraps++;
    }
  }
}


void TransTable::PrintSuitStats(
  int trick,
  int hand)
{
  int hist[DISTS_PER_ENTRY + 1];
  int num_wraps;

  TransTable::UpdateSuitHist(trick, hand, hist, &num_wraps);

  fprintf(fp, "Suit histogram for trick %d, hand %s\n",
          trick, players[hand]);
  TransTable::PrintHist(hist, num_wraps, DISTS_PER_ENTRY);
}


void TransTable::PrintAllSuitStats()
{
  suitWraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    suitHist[i] = 0;

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Suit, Trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "==========================\n\n");
      TransTable::PrintSuitStats(trick, hand);
    }
  }

  fprintf(fp, "Overall suit histogram\n");
  TransTable::PrintHist(suitHist, suitWraps, DISTS_PER_ENTRY);
}


void TransTable::PrintSummarySuitStats()
{
  int hist[DISTS_PER_ENTRY + 1];
  int count, prod_sum, prod_sumsq,
                        max_len, num_wraps;

  suitWraps = 0;
  for (int i = 0; i <= DISTS_PER_ENTRY; i++)
    suitHist[i] = 0;

  fprintf(fp, "Suit depth statistics\n\n");

  fprintf(fp, "%5s %6s %7s %7s %7s %7s %7s P%-4.2f\n",
          "Trick",
          "Player",
          "Entries",
          "Full",
          "Average",
          "Std.dev",
          "Maximum",
          TT_PERCENTILE);

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      TransTable::UpdateSuitHist(trick, hand, hist, &num_wraps);
      TransTable::MakeHistStats(hist,
                                &count, &prod_sum, &prod_sumsq, &max_len, DISTS_PER_ENTRY);

      double mean = 0., var = 0.;
      if (count > 0)
      {
        mean = prod_sum / static_cast<double>(count);
        var = prod_sumsq /
               static_cast<double>(count - mean * mean);
        if (var < 0.)
          var = 0.;
      }

      int percentile =
        TransTable::CalcPercentile(hist,
                                   TT_PERCENTILE * count, DISTS_PER_ENTRY);

      if (count > 0)
        fprintf(fp, "%5d %-6s %7d %7d %7.2f %7.2f %7d %7d\n",
                trick,
                players[hand],
                count,
                num_wraps,
                mean,
                sqrt(var),
                max_len,
                percentile);
      else
        fprintf(fp, "%5d %-6s %7d %7d %7s %7s %7d %7d\n",
                trick,
                players[hand],
                count,
                num_wraps,
                "-",
                "-",
                max_len,
                percentile);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");
}


TransTable::winBlockType * TransTable::FindMatchingDist(
  int trick,
  int hand,
  int handDistSought[DDS_HANDS])
{
  winBlockType * bp;
  distHashType * dp;
  int handDist[DDS_HANDS];

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      bp = dp->list[i].posBlock;
      TransTable::KeyToDist(dp->list[i].key, handDist);

      bool same = true;
      for (int h = 0; h < DDS_HANDS; h++)
      {
        if (handDist[h] != handDistSought[h])
        {
          same = false;
          break;
        }
      }
      if (same)
        return bp;
    }
  }
  return nullptr;
}


void TransTable::PrintEntriesBlock(
  winBlockType * bp,
  unsigned char lengths[DDS_HANDS][DDS_SUITS])
{
  char line[40];
  char lines[2][80];

  TransTable::LenToStr(lengths, line);

  sprintf(lines[0],
          "%d matches for %s\n", bp->nextMatchNo, line);
  memset(lines[1], '=', 71);
  lines[1][71] = '\0';

  fprintf(fp, "%s%s\n\n", lines[0], lines[1]);

  for (int j = 0; j < bp->nextMatchNo; j++)
  {
    fprintf(fp, "Entry number %3d\n", j + 1);
    fprintf(fp, "----------------\n\n");
    TransTable::PrintMatch(&bp->list[j], lengths);
  }
}



void TransTable::PrintEntriesDistAndCards(
  int trick,
  int hand,
  unsigned short * aggrTarget,
  int handDist[DDS_HANDS])
{
  char line[40];
  unsigned char len[DDS_HANDS][DDS_SUITS];

  winBlockType * bp =
    TransTable::FindMatchingDist(trick, hand, handDist);

  TransTable::DistToLengths(trick, handDist, len);

  fprintf(fp, "Looking up entry for trick %d, hand %d\n",
          trick, hand);
  TransTable::LenToStr(len, line);
  fprintf(fp, "%s\n\n", line);

  if (! bp)
  {
    fprintf(fp, "Entry not found\n\n");
    return;
  }

  unsigned * ab0 = aggr[ aggrTarget[0] ].aggrBytes[0];
  unsigned * ab1 = aggr[ aggrTarget[1] ].aggrBytes[1];
  unsigned * ab2 = aggr[ aggrTarget[2] ].aggrBytes[2];
  unsigned * ab3 = aggr[ aggrTarget[3] ].aggrBytes[3];

  winMatchType TTentry;
  TTentry.topSet1 = ab0[0] | ab1[0] | ab2[0] | ab3[0];
  TTentry.topSet2 = ab0[1] | ab1[1] | ab2[1] | ab3[1];
  TTentry.topSet3 = ab0[2] | ab1[2] | ab2[2] | ab3[2];
  TTentry.topSet4 = ab0[3] | ab1[3] | ab2[3] | ab3[3];

  int matchNo = 1;
  int n = bp->nextMatchNo - 1;
  winMatchType * wp = &bp->list[n];

  for (int i = n; i >= 0; i--, wp--)
  {
    if ((wp->topSet1 ^ TTentry.topSet1) & wp->topMask1)
      continue;

    if (wp->lastMaskNo != 1)
    {
      if ((wp->topSet2 ^ TTentry.topSet2) & wp->topMask2)
        continue;

      if (wp->lastMaskNo != 2)
      {
        if ((wp->topSet3 ^ TTentry.topSet3) & wp->topMask3)
          continue;
      }
    }

    fprintf(fp, "Match number %d\n", matchNo++);
    fprintf(fp, "---------------\n");
    TransTable::PrintMatch(&bp->list[i], len);
  }

  if (matchNo == 1)
    fprintf(fp, "%d matches for suit, none for cards\n\n", n);
  else
    fprintf(fp, "\n");
}


void TransTable::PrintEntriesDist(
  int trick,
  int hand,
  int handDist[DDS_HANDS])
{
  unsigned char len[DDS_HANDS][DDS_SUITS];

  winBlockType * bp =
    TransTable::FindMatchingDist(trick, hand, handDist);

  TransTable::DistToLengths(trick, handDist, len);

  if (! bp)
  {
    fprintf(fp, "Entry not found: Trick %d, hand %d\n",
            trick, hand);
    char line[80];
    TransTable::LenToStr(len, line);
    fprintf(fp, "%s\n\n", line);
    return;
  }

  TransTable::PrintEntriesBlock(bp, len);
}


void TransTable::PrintEntries(
  int trick,
  int hand)
{
  winBlockType * bp;
  distHashType * dp;
  int handDist[DDS_HANDS];
  unsigned char lengths[DDS_HANDS][DDS_SUITS];

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      bp = dp->list[i].posBlock;
      TransTable::KeyToDist(dp->list[i].key, handDist);
      TransTable::DistToLengths(trick, handDist, lengths);

      TransTable::PrintEntriesBlock(bp, lengths);
    }
  }
}


void TransTable::PrintAllEntries()
{
  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Entries, trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "==============================\n\n");
      TransTable::PrintEntries(trick, hand);
    }
  }
  fprintf(fp, "\n");
}


void TransTable::UpdateEntryHist(
  int trick,
  int hand,
  int hist[],
  int * num_wraps)
{
  distHashType * dp;

  * num_wraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    hist[i] = 0;

  for (int hashkey = 0; hashkey < 256; hashkey++)
  {
    dp = &TTroot[trick][hand][hashkey];
    for (int i = 0; i < dp->nextNo; i++)
    {
      int c = dp->list[i].posBlock->nextMatchNo;
      hist [c]++;
      suitHist[c]++;

      if (c != dp->list[i].posBlock->nextWriteNo)
      {
        (*num_wraps)++; // Not entirely correct
        suitWraps++;
      }
    }
  }
}


void TransTable::PrintEntryStats(
  int trick,
  int hand)
{
  int hist[BLOCKS_PER_ENTRY + 1];
  int num_wraps;

  TransTable::UpdateEntryHist(trick, hand, hist, &num_wraps);

  fprintf(fp, "Entry histogram for trick %d, hand %s\n",
          trick, players[hand]);
  TransTable::PrintHist(hist, num_wraps, BLOCKS_PER_ENTRY);
}


void TransTable::PrintAllEntryStats()
{
  suitWraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    suitHist[i] = 0;

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      fprintf(fp, "Entry, trick %d, hand %s\n", trick, players[hand]);
      fprintf(fp, "============================\n\n");
      TransTable::PrintEntryStats(trick, hand);
    }
  }

  fprintf(fp, "Overall entry histogram\n");
  TransTable::PrintHist(suitHist, suitWraps, BLOCKS_PER_ENTRY);
}


int TransTable::EffectOfBlockBound(
  int hist[],
  int size)
{
  // Calculates the number of blocks used if the blocks
  // are divided up in units of size, rather than in units
  // of BLOCKS_PER_ENTRY. Only makes sense if size is less
  // than BLOCKS_PER_ENTRY, as we won't have statistics for
  // how many blocks above BLOCKS_PER_ENTRY would be created
  // if BLOCKS_PER_ENTRY were larger.

  int cum_memory = 0;
  int unit_size = 0;

  for (int i = 1; i <= BLOCKS_PER_ENTRY; i++)
  {
    if ((i - 1) % size == 0)
      unit_size += size;

    cum_memory += hist[i] * unit_size;
  }
  return cum_memory;
}


// #define TT_MEMORY_SCENARIO

void TransTable::PrintSummaryEntryStats()
{
  int hist[BLOCKS_PER_ENTRY + 1];
  int count, prod_sum, prod_sumsq,
                        max_len, num_wraps;

  int cumCount = 0;
  double cumProd = 0.;
#ifdef TT_MEMORY_SCENARIO
  int cumMemory = 0;
#endif

  suitWraps = 0;
  for (int i = 0; i <= BLOCKS_PER_ENTRY; i++)
    suitHist[i] = 0;

  fprintf(fp, "Entry depth statistics\n\n");

  fprintf(fp, "%5s %6s %7s %7s %7s %7s %7s P%-4.2f\n",
          "Trick",
          "Player",
          "Entries",
          "Full",
          "Average",
          "Std.dev",
          "Maximum",
          TT_PERCENTILE);

  for (int trick = 11; trick >= 1; trick--)
  {
    for (int hand = 0; hand < DDS_HANDS; hand++)
    {
      TransTable::UpdateEntryHist(trick, hand, hist, &num_wraps);
      TransTable::MakeHistStats(hist,
                                &count, &prod_sum, &prod_sumsq, &max_len, BLOCKS_PER_ENTRY);

      cumCount += count;
      cumProd += prod_sum;
#ifdef TT_MEMORY_SCENARIO
      cumMemory += TransTable::EffectOfBlockBound(hist, 20);
#endif

      double mean = prod_sum / static_cast<double>(count);
      double var = prod_sumsq /
                    static_cast<double>(count - mean * mean);
      if (var < 0.)
        var = 0.;

      int percentile =
        TransTable::CalcPercentile(hist,
                                   TT_PERCENTILE * count, BLOCKS_PER_ENTRY);

      fprintf(fp, "%5d %-6s %7d %7d %7.2f %7.2f %7d %7d\n",
              trick,
              players[hand],
              count,
              num_wraps,
              mean,
              sqrt(var),
              max_len,
              percentile);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");

  fprintf(fp, "Blocks counted\t%8d\n", cumCount);

  fprintf(fp, "Blocks produced\t%8d\n", TransTable::BlocksInUse());

#ifdef TT_MEMORY_SCENARIO
  fprintf(fp, "Mem scenario\t%7.2f%%\n",
          100. * cumMemory /
          (static_cast<double>(BLOCKS_PER_ENTRY * cumCount)));
#endif

  if (cumCount)
    fprintf(fp, "Fullness\t%7.2f%%\n",
            100. * cumProd / (BLOCKS_PER_ENTRY * cumCount));
  fprintf(fp, "\n");
}


void TransTable::PrintPageSummary()
{
  if (pageStats.numResets == 0)
    return;

  fprintf(fp, "Page statistics\n\n");

  fprintf(fp, "%-10s %6s %6s\n",
          "Type", "Number", "Avg");

  fprintf(fp, "%-10s %6d\n",
          "Resets",
          pageStats.numResets);
  fprintf(fp, "%-10s %6d %6.2f\n",
          "calloc",
          pageStats.numCallocs,
          pageStats.numCallocs / static_cast<double>(pageStats.numResets));
  fprintf(fp, "%-10s %6d %6.2f\n",
          "free",
          pageStats.numFrees,
          pageStats.numFrees / static_cast<double>(pageStats.numResets));
  fprintf(fp, "%-10s %6d %6.2f\n\n",
          "harvest",
          pageStats.numHarvests,
          pageStats.numHarvests / static_cast<double>(pageStats.numResets));
}
